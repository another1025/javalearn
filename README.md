[TOC]

# 1.Java多线程学习笔记

## 1.1 多线程相关概念

​	Java的并发依赖于JVM的实现和CPU指令

### 1.1.1 volatile

* volatile修饰符保证了在多处理环境中，共享变量的'可见性'。
* 可见性 - > 当一个线程修改一个共享变量时，其他线程可以读取到修改的值。
* 它比synchronized更轻量级
* 在Intel处理器下的实现
  * volatile修饰的变量，在进行写操作的时候(比如使用new关键字)会多出一行汇编代码 lock ...
  * lock前缀指令在多核处理器下会引发两件事情
    * 1.将当前处理器缓存行的数据写回系统内存
    * 2.这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效(CPU会重新从内存中读取修改后的值)
  * 缓存一致性协议MESI，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了
  * 处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态
* Lock前缀指令会引起处理器缓存回写到内存
  * Lock前缀指令执行期间，声言处理器的Lock#信号，确保声言信号期间，处理器可以独占任何共享内存（会锁住总线，导致其他CPU不能访问总线，也就不能访问系统内存）
  * 导致其他处理器的缓存无效，通过嗅探技术保证处理器缓存、系统内存的数据在总线上保持一致

### 1.1.2 synchronized

### 1.1.3 原子操作的实现原理

* CAS实现原子操作的三大问题
  * ABA问题（通过版本号来解决）
  * 循环时间长开销大
  * 只能保证一个共享变量的原子操作



## 1.2 Java内存模型(Java Memory Model)

### 1.2.1 Java内存模型基础

* Java内存模型的抽象结构
  * 实例域、静态域、数组元素都存储在堆内存中，堆内存在线程之间共享。
  * 局部变量、方法定义参数、异常处理器参数不会再线程间共享。
  * LocalMemory（本地内存，JMM的一个抽象概念，并不真实存在）
* JMM控制主内存和线程本地内存的交互，提供内存可见性保证。
  * 编译器和处理器常常会对指令做重排序，重排序分3种。
    * 1.编译器优化的重排序，在不改变。
    * 2.指令集并行的重排序，将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变对应指令的执行顺序
    * 3.

